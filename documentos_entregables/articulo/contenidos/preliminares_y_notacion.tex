%
% Sección de preliminares.
% Artículo.
% Proyecto Lovelace.
%

\section{Preliminares}

% TODO: ¿Qué más va en los preliminares? Candidatos:
% AES
% Redes Feistel
% CBC MAC

\subsection{Notación}

% TODO: Revisar todas las fórmulas y pseudocódigos y poner las cuestiones
% relacionadas de notación en este párrafo.

Se denotarán a todas las cadenas de bits de longitud $ n $ como $ \{ 0, 1 \}^n $.

%
%  % Cambio el título a <<Estructura de un número de tarjeta bancaria>>, los
%  % números de las tarjetas de débido también tiene la misma composición.
%  \subsection{Estructura de un número de tarjeta bancaria}
%  También llamado PAN por sus siglas en inglés, se refiere al número de una
%  tarjeta bancaria, está compuesto por tres partes:
%
%  \begin{enumerate}
%    \item IIN
%    \item Número de cuenta
%    \item Dígito verificador
%  \end{enumerate}
%
%  La longitud del número de tarjeta puede variar entre 12 y 19 dígitos y el
%  primero conjunto de números está regido bajo el estándar ISO/IEC-7812.
%
%  El IIN (\textit{Número de identificación del emisor} por sus siglas en
%  inglés), está compuesto por los primeros seis dígitos de la tarjeta; permite
%  identificar el banco emisor, el tipo de la tarjeta, la marca (Visa,
%  AmericanExpress) y el nivel de la tarjeta (Clásica, Gold).  El primer dígito
%  del IIN es conocido como MII (\textit{Identificador principal de la Industria}
%  por sus siglas en inglés) y su función es señalar la rama de la industria a la
%  que pertenece la entidad que emitió la tarjeta; por ejemplo, los bancos y la
%  industria financiera tienen asignados los números 4 y 5~\cite{iso_7812}.
%
%  Los dígitos que le siguen al INN, excepto el último, son los que componen el
%  número de cuenta y su tamaño varía dependiendo de la longitud del PAN; la
%  longitud máxima, sin embargo, es de 12 dígitos, por lo que cada emisor tiene
%  $10^{12}$ posibles números de cuenta.
%
%  El dígito verificador es calculado mediante el algoritmo de Luhn y su
%  propósito es ayudar a distinguir entre un PAN válido y un PAN inválido.
%  El algoritmo se describe a continuación.
%
%  \subsection{Algoritmo de Luhn}
%
%  La especificación de este algoritmo se encuentra en~\cite{iso_7812}. Se tiene
%  como entrada un número de tarjeta $ x = \{x_n, x_{n-1}, \dots, x_2, x_1\}$ de
%  longitud $ n $; para calcular el dígito verificador se hace lo siguiente:
%  \begin{enumerate}
%    \item Obtener los conjuntos $x_{par} = \{x_2, x_4, \dots\}$ y
%      $x_{impar} = \{x_3, x_5, \dots\}$.
%    \item Obtener el doble de cada uno de los elementos del conjunto $x_{par}$.
%      $x_{par\_doble} = \{2 \times x_2, 2 \times x_4, \dots\}$.
%      $\forall x_i \in x_{par\_doble} (x_i > 9 \rightarrow
%      x_i = (x_i \mod 10) + 1)$.
%    \item Obtener la suma $ S $ de los elementos de los conjuntos $x_{par\_doble}$
%      y $x_{impar}$.
%    \item Finalmente, $x_1 = (S \times 9) \mod 10$
%  \end{enumerate}

\subsection{Cifrado por bloques}

Un cifrado por bloques es un cifrado simétrico que se define por la función $ E:
\mathcal{M} \times \mathcal{K} \rightarrow \mathcal{C} $ en donde $ \mathcal{M} $
es el espacio de textos en claro, $ \mathcal{K} $ es el espacio de llaves y $
\mathcal{C} $ es el espacio de mensajes cifrados. Tanto los mensajes en claro
como los cifrados tienen una misma longitud $ n $, que representa el tamaño del
bloque \cite{menezes}.

Los cifrados por bloque son un elemento de construcción fundamental para otras
primitivas criptográficas. Muchos de los algoritmos tokenizadores que se
presentan en este trabajo los ocupan de alguna forma. Las definiciones de los
algoritmos son flexibles en el sentido de que permiten instanciar cada
implementación con el cifrado por bloques que se quiera; en el caso de las
implementaciones hechas para este trabajo se ocupó AES (\textit{Advanced
Encryption Standard}) en la mayoría de los casos.

\subsection{Cifrado que preserva el formato}

% Coregir letra del contradominio de la función de FPE e investigar qué
% demonios es.
% Pues no entiendo por el contexto qué significa; de momento la borré.

% ¿Tweak va en itálicas?
% http://www.rae.es/consultas/los-extranjerismos-y-
% latinismos-crudos-no-adaptados-deben-escribirse-en-cursiva
% Pues, a diferencia de token, me parece que con la «tw» sí hacemos uso de
% la pronunciación en inglés; cuando menos ahora no se me ocurre una palabra
% en español que tenga «tw».
% Sí, debe de ir en cursivas, o cambiar por <<ajuste>>.

Un cifrado que preserva el formato (en inglés \textit{Format-preserving
Encryption}, FPE) puede ser visto como un cifrado simétrico en donde el mensaje
en claro y el mensaje cifrado mantienen un formato en común. Formalmente, de
acuerdo a lo definido en \cite{DBLP:conf/sacrypt/BellareRRS09}, se trata de una
función $ E: \mathcal{K} \times \mathcal{N} \times \mathcal{T} \times
\mathcal{X} \rightarrow \mathcal{X} $, en donde los conjuntos $ \mathcal{K} $, $
\mathcal{N} $, $ \mathcal{T} $, $ \mathcal{X} $ corresponden al espacio de
llaves, espacio de formatos, espacio de \textit{tweaks} y el dominio,
respectivamente. El proceso de cifrado de un elemento del dominio con respecto a
una llave $ K $, un formato $ N $ y un \textit{tweak} $ T $ se escribe como  $
E_K^{N,T}(X) $. El proceso inverso es también una función $ D: \mathcal{K}
\times \mathcal{N} \times \mathcal{T} \times \mathcal{X} \rightarrow \mathcal{X}
$, en donde $ D_K^{N,T}\big( E_K^{N,T}(X) \big) = X $.

% ¿Hacer aquí aclaración sobre la diferencia en los dígitos verificadores
% en los espacios de orígen y destino?
% Creo que en realidad eso le aplica a todos los esquemas, por lo que mejor lo
% ponemos en el propio desarrollo.

Para lo que a este trabajo respecta, el formato usado es el de las tarjetas de
crédito: una cadena de entre 12 y 19 dígitos decimales. Esto es $ N = \{0, 1,
\dots, 9\}^n $ en donde $ 12 \leq n \leq 19 $.

% TODO: Hmmmm... técnicamente al FPE solo le damos el identificador de la
% persona, por lo que los dígitos son menos.
% ¿Pero no en un cifradro de esos utilizan la otra parte de la tarjeta como
% tweak o algo así?

En marzo de 2016 el NIST (\textit{National Institute of Standards and
Technology}) publicó un estándar referente a los cifrados que preservan el
formato\cite{nist_fpe}. En él se definen dos posibles métodos: FF1 (lo que en
este trabajo es FFX) y FF3 (lo que en este trabajo es BPS).

% TODO: ¿Hablar también sobre la clasificación que hace Rogaway?

\subsection{Generadores de números pseudoaleatorios}

Existen dos maneras de generar bits aleatorios: la primera es producir bits de
manera no determinística, donde el estado de cada uno (uno o cero) está
determinado por un proceso físico impredecible. Este tipo de generadores se
conocen como \textit{no determinísticos} (NRBG, \textit{Non-deterministic Random
Bit Generator}) o \textit{realmente aleatorios} (TRBG, \textit{Truly Random Bit
Generator}). La segunda manera, que es la que se explicará a detalle en esta
sección, es calcular los bits de forma determinística mediante un algoritmo.
Este tipo de generadores se conocen como \textit{determinísticos} (DRBG,
\textit{Deterministic Random Bit Generator}), y por lo tanto, los números que
genera se denominan \textit{pseudoaleatorios}.

En \cite{nist_aleatorios} el NIST establece un estándar para dos generadores
pseudoaleatorios: uno basado en funciones hash y el otro en cifrados por bloque.
La idea general para ambos es la misma: a partir de un valor inicial, llamado
semilla, usar el mecanismo interno (la función hash o el cifrado por bloque) a
lo largo de las distintas peticiones sobre el generador para producir cadenas de
bits de aspecto aleatorio. Las producciones del generador son impredecibles
mientras la semilla se mantenga en secreto. La mejor práctica es que la semilla
sea producto de un generador no determinístico.

% El documento del NIST tiene 110 páginas. Lo que realmente importa es lo del
% párrafo de abajo.

El método para generar bits pseudoaleatorios con una función hash consiste en ir
concatenando de forma consecutiva los valores hash derivados de la semilla hasta
alcanzar el número de bytes deseados. Primero se genera un hash de la semilla y
después se incrementa su valor; de esta forma nunca se obtiene el mismo hash dos
veces. Por otra parte, el método basado en un cifrado por bloques consiste en
usar el modo de operación de contador con un cifrado por bloques estándar (AES o
TDES), en donde la semilla juega el papel del vector de inicialización.
