%
% Sección de FFX.
% Artículo.
% Proyecto Lovelace.
%

\subsection{FFX (\textit{Format-preserving Feistel-based Encryption})}

Cifrado que preserva el formato presentado en \cite{ffx_1} por Mihir Bellare,
Phillip Rogaway y Terence Spies.  En su forma más general, el algoritmo se
compone de 9 parámetros que permiten cifrar cadenas de cualquier longitud en
cualquier alfabeto; los autores también proponen dos formas más específicas (dos
colecciones de parámetros) para alfabetos binarios y alfabetos decimales: A2 y
A10, respectivamente. De aquí en adelante se hablará solamente de la colección
A10.

% TODO: Poner significado de AES CBC MAC, ¿en los preliminares?

FFX ocupa una red Feistel alternante junto con una adaptación de AES-CBC-MAC
(usada como función de ronda) para lograr preservar el formato. La operación
general del algoritmo se describe completamente por la operación de una red
alternante:
\begin{equation}
  \begin{split}
    L_{i} &=
    \begin{cases}
      F_k(R_{i - 1}) \oplus L_{i - 1},  & \text{si } i \text{ es par} \\
      L_{i - 1},                        & \text{si } i \text{ es impar}
    \end{cases}
    \\
    R_{i} &=
    \begin{cases}
      R_{i - 1},                        & \text{si } i \text{ es par} \\
      F_k(L_{i - 1}) \oplus R_{i - 1},  & \text{si } i \text{ es impar}
    \end{cases}
  \end{split}
\end{equation}

% TODO: Hablar sobre la operación de combinación.

En la figura \ref{ffx_ronda} se describe a la función de ronda. La idea general
consiste en interpretar la salida de AES CBC MAC de forma que tenga el formato
deseado. El valor de $ m $ corresponde al \textit{split} en la ronda actual,
esto es, la longitud de la cadena de entrada.

% TODO: ¿Pongo toda la concatenación de parámetros inútiles?
% Así se ve más limpio todo, claro que estrictamente hablando, no es FFX A10.

\begin{algorithm}
  \caption{\label{ffx_ronda} Función de ronda de FFX A10}
  \begin{algorithmic}[1]
    \Function{FFX-AES-CBC-MAC}{$ x, k, t $}
      \State $ a \gets x \ || \ t $
      \State $ b \gets $ \Call{aes\_cbc\_mac}{$ a, k $}
      \State $ y\prime \gets a[1 ... 64] $,
        $ y\prime\prime \gets a[65 ... 128] $
      \If{$ m \leq 9 $}
        \State $ c \gets y\prime\prime \mod 10^m $
      \Else
        \State $ c \gets (y\prime \mod 10^{m - 9})
          \times 10^9 + (y\prime\prime \mod 10^m) $
      \EndIf
      \State \Return{$ c $}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

% Esto suena a broma, solo cambiamos el orden.

Con la clasificación del PCI, este método cae en los reversibles
criptográficos. Con la clasificación propuesta en este trabajo, se trata de un
criptográfico reversible.
