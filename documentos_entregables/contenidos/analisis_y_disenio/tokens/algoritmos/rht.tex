%
% Algoritmo de tipo híbrido reversible
% «Several Proofs of Security for a Tokenization Algorithm»
% Proyecto Lovelace.
%

\subsubsection{\textit{Several Proofs of Security for a Tokenization
  Algorithm}}

Longo, Aragona y Sala~\cite{aragona}, propusieron en 2017, un algoritmo del
tipo híbrido reversible. Este está basado en un cifrado de bloques con una
llave secreta y una entrada adicional.

El número de una tarjeta (\gls{gl:pan}) está conformado por tres partes
concatenadas: el número que identifica al emisor de la tarjeta, el que
identifica la cuenta y un número de verificación. Se considera que
reemplazar la primera parte por un código fijo da como resultado un
\gls{gl:token} ya.

Las entradas del algoritmo son el \gls{gl:pan} y una entrada adicional.
Esta última permite que se generen varios \glspl{gl:token} para el mismo
\gls{gl:pan}.

El algoritmo necesita una función $f$ pública que, dada una cadena
de longitud $m$ regrese una de longitud $n$ (véase sección de funciones 
hash~\ref{sec:hash}). Se toman solo cifrados cuyo tamaño de bloque sea de
mínimo 128 bits. La función $f$ se encarga de poner el relleno en la entrada
para completar el bloque del cifrado y permitir la creación de varios
\glspl{gl:token} para el mismo \gls{gl:pan} utilizando la misma llave en el
proceso de cifrado. Finalmente, el algoritmo necesita una base de datos segura
que se encargará de contener los pares \gls{gl:pan}-\gls{gl:token}. Al momento
de crear los \glspl{gl:token}, se necesita acceder a la base de datos
mediante una \gls{gl:funcion_booleana} \textit{comprobar} que revisa si el
\gls{gl:token} generado ya está almacenado en la base.

Como se desea obtener un \gls{gl:token} que
tenga el mismo número de dígitos que el \gls{gl:pan} (longitud $l$)
ingresado, se deben tomar en cuenta solo una fracción de las posibles salidas
del cifrado $E$; para resolver este problema, se utiliza un método conocido
como el \gls{gl:cifrado_caminata_ciclica}.

El algoritmo de tokenización es el siguiente:
\begin{pseudocodigo}[%
    caption={Híbrido reversible, método de tokenización}
  ]
  entrada: PAN p; entrada_adicional u; llave k
  salida:  token
  inicio
    $t = f(u, p)$ (paso 1)
    $c = E(k, t)$ (paso 2)
    si $(\bar{c} \mod 2^n) \geq 10^l$
      $t = c$
      Regresar al paso 2 (obtener $c$).
    fin
    $token = {[\bar{c} \mod 2^n]}^l_{10}$
    si $comprobar(token) =$ verdadero
      $u = u + 1$
      Regresar al paso 1 (obtener $t$).
    fin
    regresar token
  fin
\end{pseudocodigo}
